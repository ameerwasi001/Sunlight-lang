open head: v
head ? v@SltList -> listHead: v

open tail: v
tail ? v@SltList -> listTail: v

open map_and_filter: mf, rf, xs;
map_and_filter ? [] = xs -> []
map_and_filter ? xs@SltList -> if rf: head: xs then [mf: head: xs] .. map_and_filter: mf, rf, tail: xs else map_and_filter: mf, rf, (tail: xs)

open take: n, ls
take ? ls@SltList & n <= 1 -> []
take ? [] = ls | n < 1 -> []
take ? ls@SltList -> [head: ls] .. take: n-1, tail: ls

open last: s
last ? (tail: s)@SltNum -> head: s
last ? s@SltList -> last: tail: s

open fold: f, i, xs
fold ? [] = xs -> i
fold ? xs@SltList -> f: (head: xs), fold: f, i, tail: xs

open seq: f, s
seq ? [] = s -> []
seq ? [] = f -> []
seq ? s@SltList & f@SltList -> (map: (head: f), s) .. seq: (tail: f), s

open fmap: f, s
fmap ? s@SltList -> map: f, s

fmap ? s@SltFunc & f@SltFunc -> \f: s: x

map: f, xs <- every xs is f: x
filter: f, xs <- every xs is x if f: x
len: ls <- fold: \a, b -> b+1, 0, ls
reduce: f, ls <- fold: f, (head: ls), tail: ls

range: a, b <- take: b+1, (fl: a where fl: n <- [n] .. fl: n+1 end)
replicate: v, n <- map: (const: v), range: 1, n
infiniteList: init, change <- fls: init where fls: n <- [n] .. fls: change: n end