open head: v
head ? v@SltList -> listHead: v

open tail: v
tail ? v@SltList -> listTail: v

open map_and_filter: mf, rf, xs
map_and_filter ? [] = xs -> []
map_and_filter ? xs@SltList -> if rf: head: xs then [mf: head: xs] .. map_and_filter: mf, rf, tail: xs else map_and_filter: mf, rf, tail: xs

open take: n, ls
take ? ls@SltList & n <= 1 -> []
take ? [] = ls | n < 1 -> []
take ? ls@SltList -> [head: ls] .. take: n-1, tail: ls

open last: s
last ? (tail: s)@SltNum -> head: s
last ? s@SltList -> last: tail: s

open fold: f, i, xs
fold ? [] = xs -> i
fold ? xs@SltList -> f: head: xs,, fold: f, i, tail: xs

open zipWith: f, as, bs
zipWith ? [] = as | [] = bs -> []
zipWith ? as@SltList & bs@SltList -> [f: (head: as), head: bs] .. zipWith: f, (tail: as), tail: bs

map: f, xs <- every xs is f: x
filter: f, xs <- every xs is x if f: x
len: ls <- fold: \a, b -> b+1, 0, ls
reduce: f, ls <- fold: f, (head: ls), tail: ls
zip <- zipWith: (,)
zipList <- zipWith: [,]

generate: f, a, b <- take: b+1, infiniteList: a, f
range <- generate: inc
replicate: v, n <- map: const: v,, range: 1, n
infiniteList: init, change <- fls: init where fls: n <- [n] .. fls: change: n end